# 一、物理计算机中的问题

## 1、为什么会有高速缓存

- 计算机存储设备和处理器的运算速度有几个数量级的差距；
- 加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）作为内存与处理器之间的缓冲。

## 2、运行过程：

- 将运算需要使用到的数据复制到缓存中，让运算能快速运行；
- 运算结束，再从缓存同步回内存；
- 结果：处理器无需等待缓慢的内存读写。

## 3、问题出现：

- 缓存一致性（Cache Coherence）

## 4、问题原因：

- 多处理器系统，每个处理器都有自己的Cache，而这些处理器又共享同一个主内存
- 多个处理器的运算任务涉及到同一块主存区域，将导致各自缓存不一致
<div align="center"> <img src="../pics//2395997-b488c3d74bc2521d.png" width=""/> </div>

## 5、问题解决：

- 缓存一致性协议（MSI、MESI、MOSI......）

## 6、内存模型：

- 特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

## 7、乱序优化：

- 为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化。
- 处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。
- 如果存在一个计算任务依赖于另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。

# 二、Java 内存模型
Java 内存模型的作用：

- 屏蔽各种硬件和操作系统的内存访问差异；
- 实现让 Java 程序在各个平台下都能达到一致的内存访问效果。
## 1、主内存与工作内存
Java 内存模型的主要目标：

- 定义程序中各个“变量”的访问规则；
- 此处的“变量”包括实例字段、静态字段和构成数组对象的元素；
- 因局部变量与方法参数是线程私有【注1】，不会被共享，不存在竞争问题，所以“变量”不包括他们。

Java 内存模型规定：

- 所有的变量都存储在主内存
- 每条线程有自己的工作内存
- 工作内存保存了被该线程使用到的变量的主内存副本拷贝【注2】
- 线程对变量的所有操作都是在工作内存中进行的，不可直接读写主内存中的变量【注3】
- 不同线程无法直接访问对方工作内存中的变量
- 线程间变量值的传递都需要通过主内存来完成
<div align="center"> <img src="../pics//2019-04-10_092422.png" width=""/> </div>
从上图来看：硬件 <===> Java 虚拟机

- 处理器   <===> Java 线程
- 高速缓存 <===> 工作内存
- 缓存一致性协议 <===> Save 和 Load 操作

注意：

- 若局部变量是 reference 类型，它引用的对象在 Java 堆中可能被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中，它是线程私有的。
- 拷贝副本：假设线程中访问10M的对象，也会把10M内存复制一份吗？不会。这个对象的引用、对象在某个线程访问到的字段是有可能存在拷贝的，但不会把整个对象拷贝一份。
- volatile 变量依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来好像是直接在主内存中读写一样。
## 2、内存间交互操作
8种原子操作：

- lock(锁定)：作用于主内存中的变量，把一个变量标识为一条线程独占的状态。
- unlock(解锁)：作用于主内存中的变量，把一个处于锁定状态的变量释放出来，之后可被其它线程锁定。
- read(读取)：作用于主内存中的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load(加载)：作用于工作内存中的变量，把read操作从主内存中得到的变量的值放入工作内存的变量副本中。
- use(使用)：作用于工作内存中的变量，把工作内存中一个变量的值传递给执行引擎。
- assign(赋值)：作用于工作内存中的变量，把一个从执行引擎接收到的值赋值给工作内存中的变量。
- store(存储)：作用于工作内存中的变量，把工作内存中的一个变量的值传送到主内存中。
- write(写入)：作用于主内存中的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。

注意：

- 把变量从主内存复制到工作内存，必须顺序执行 read 和 load
- 把变量从工作内存同步到主内存，必须顺序执行 store 和 write
- 上述操作必须顺序执行，但不要求连续执行

执行8种基本操作时的规则：

- 不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存被读取了，但是工作内存不接受，或者从工作内存回写了但是主内存不接受。
- 不允许一个线程丢弃它最近的一个assign操作，即变量在工作内存被更改后必须同步改更改回主内存。 
- 工作内存中的变量在没有执行过assign操作时，不允许无意义的同步回主内存。
- 在执行use前必须已执行load，在执行store前必须已执行assign。 
- 一个变量在同一时刻只允许一个线程对其执行lock操作，一个线程可以对同一个变量执行多次lock，但必须执行相同次数的unlock操作才可解锁。
- 一个线程在lock一个变量的时候，将会清空工作内存中的此变量的值，执行引擎在use前必须重新read和load。
- 线程不允许unlock其他线程的lock操作。并且unlock操作必须是在本线程的lock操作之后。
- 在执行unlock之前，必须首先执行了store和write操作。

上述规则完全确定Java程序中哪些内存访问操作在并发下是安全的。

上述规则的等价定义---先行发生原则。
## 3、volatile 型变量的特殊规则
volatile 变量的两种特性：

- ①保证该变量对所有线程的可见性【这是与普通变量的最大区别】。即一个线程修改了volatile变量的值，新值对于其他线程来说是可立即得知的。
- ②禁止指令重排序

注意：

- volatile变量在各个线程的工作内存中也存在不一致的情况，但是由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可认为不存在一致性问题。
- 但Java中的运算并非原子操作，导致volatile变量的运算在并发情况下一样是不安全的。

总结：

- volatile 变量只能保证可见性
- 不能保证原子性的情况，需要加锁来保证原子性（使用 synchronized 或 java.util.concurrent 中的原子类）
- 保证原子性的情况：确保只有单一线程修改变量值，且变量不需要与其他状态变量共同参与不变约束。

选用 volatile 的意义：

- volatile 变量的读操作性能消耗和普通变量几乎没有什么区别，但是写操作可能会慢些（因需要插入内存屏障指令来保证处理器不发生乱序执行）
- volatile 与 锁 如何选择？就看 volatile 的语义能否满足使用场景的需求。

## 4、long/double 型变量的特殊规则
long 和 double 的非原子性协定：

- 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分位两次 32 位的操作，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这个 4 个操作的原子性。
## 5、原子性、可见性与有序性
原子性：

- Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store、write
- 可认为基本数据类型的访问读写是具备原子性的（忽略long、double）
- 如果需要更大原子性的保证，可使用 加锁 操作

可见性：

- 指当一个线程修改了共享变量的值，其他线程能立即得知这个修改。
- 实现：Java内存模型是通过变量在修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主存作为媒介的方式实现可见性。
- synchronized 和 final 也可实现可见性。
- 同步块的可见性由“对一个变量执行 unlock 操作之前，必须把此变量同步回主内存中”这条规则获得。
- final 关键字的可见性“被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么其他线程中就能看见final字段的值。”

有序性：

- Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。
- 前半句是指“线程内表现为串行的语义”（Within-Thread As-if-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
- Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。



## 6、先行发生原则
- Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值/发送了消息/调用了方法等。

Java内存模型下一些“天然的”先行发生关系：

- 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地来说应该是控制流顺序而不是程序代码顺序，因为要考虑分支/循环结构。
- 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一锁的lock操作。这里必须强调的是同一锁，而“后面”是指时间上的先后顺序。
- volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”是指时间上的先后顺序。
- 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束/Thread.isAlive()的返回值等手段检测到县城已经终止执行。
- 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

# 三、Java 与线程

## 1、线程的实现

## 2、线程的调度

## 3、状态转换